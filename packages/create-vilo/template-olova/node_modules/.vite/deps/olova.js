// node_modules/olova/dist/olova.js
var currentObserver = null;
function diffProps(oldProps = {}, newProps = {}, element) {
  if (newProps.className !== void 0) {
    newProps.class = newProps.className;
    delete newProps.className;
  }
  if (oldProps.className !== void 0) {
    oldProps.class = oldProps.className;
    delete oldProps.className;
  }
  for (const [key, value] of Object.entries(oldProps)) {
    if (!(key in newProps)) {
      if (key.startsWith("on")) {
        element.removeEventListener(key.slice(2).toLowerCase(), value);
      } else if (key === "style") {
        element.style.cssText = "";
      } else {
        element.removeAttribute(key);
      }
    }
  }
  for (const [key, value] of Object.entries(newProps)) {
    if (value == null) continue;
    if (oldProps[key] === value) continue;
    if (key.startsWith("on")) {
      const eventName = key.slice(2).toLowerCase();
      if (oldProps[key]) {
        element.removeEventListener(eventName, oldProps[key]);
      }
      element.addEventListener(eventName, value);
    } else if (key === "ref") {
      if (value && typeof value === "object" && "current" in value) {
        value.current = element;
      } else if (typeof value === "function") {
        value(element);
      }
    } else if (key === "style") {
      const style = element.style;
      if (typeof value === "object") {
        Object.assign(style, value);
      } else {
        style.cssText = value;
      }
    } else {
      element.setAttribute(key, value);
    }
  }
}
function diffChildren(oldChildren, newChildren, parent) {
  const oldChildrenArray = Array.isArray(oldChildren) ? oldChildren.flat() : [oldChildren];
  const newChildrenArray = Array.isArray(newChildren) ? newChildren.flat() : [newChildren];
  const maxLength = Math.max(oldChildrenArray.length, newChildrenArray.length);
  for (let i = 0; i < maxLength; i++) {
    const oldChild = oldChildrenArray[i];
    const newChild = newChildrenArray[i];
    if (oldChild && !newChild) {
      if (oldChild instanceof Node) {
        parent.removeChild(oldChild);
      }
      continue;
    }
    if (!oldChild && newChild) {
      const node = newChild instanceof Node ? newChild : document.createTextNode(String(newChild));
      parent.appendChild(node);
      continue;
    }
    if (oldChild instanceof Node && newChild instanceof Node) {
      if (oldChild.nodeType !== newChild.nodeType || oldChild.nodeName !== newChild.nodeName) {
        parent.replaceChild(newChild, oldChild);
      } else {
        diffProps(oldChild.attributes, newChild.attributes, oldChild);
        diffChildren(
          Array.from(oldChild.childNodes),
          Array.from(newChild.childNodes),
          oldChild
        );
      }
    } else if (oldChild !== newChild) {
      const node = parent.childNodes[i];
      if (node) {
        node.textContent = String(newChild);
      }
    }
  }
}
var Signal = class {
  constructor(value) {
    this._value = value;
    this.observers = /* @__PURE__ */ new Map();
  }
  get value() {
    if (currentObserver) {
      if (!this.observers.has("_root")) {
        this.observers.set("_root", /* @__PURE__ */ new Set());
      }
      this.observers.get("_root").add(currentObserver);
    }
    return this._value;
  }
  set value(newValue) {
    if (this._value === newValue) return;
    const oldValue = this._value;
    this._value = newValue;
    if (this.observers.has("_root")) {
      for (const observer of this.observers.get("_root")) {
        observer();
      }
    }
    if (typeof oldValue === "object" && typeof newValue === "object") {
      const allProps = /* @__PURE__ */ new Set([
        ...Object.keys(oldValue),
        ...Object.keys(newValue)
      ]);
      for (const prop of allProps) {
        if (oldValue[prop] !== newValue[prop] && this.observers.has(prop)) {
          for (const observer of this.observers.get(prop)) {
            observer();
          }
        }
      }
    }
  }
  observe(property, observer) {
    if (!this.observers.has(property)) {
      this.observers.set(property, /* @__PURE__ */ new Set());
    }
    this.observers.get(property).add(observer);
  }
  unobserve(property, observer) {
    if (this.observers.has(property)) {
      this.observers.get(property).delete(observer);
    }
  }
};
function State(initialValue) {
  const sig = new Signal(initialValue);
  const getter = () => sig.value;
  getter.toString = () => sig.value;
  getter.observe = (prop, fn) => sig.observe(prop, fn);
  getter.unobserve = (prop, fn) => sig.unobserve(prop, fn);
  return [
    getter,
    (newValue) => {
      sig.value = typeof newValue === "function" ? newValue(sig.value) : newValue;
    }
  ];
}
function Effect(fn) {
  const execute = () => {
    currentObserver = execute;
    fn();
    currentObserver = null;
  };
  execute();
}
function Memo(fn) {
  const [get, set] = State(fn());
  Effect(() => set(fn()));
  return get;
}
function Ref(initialValue) {
  const [get, set] = State({
    current: initialValue,
    toString() {
      return this.current;
    },
    valueOf() {
      return this.current;
    }
  });
  const ref = {
    get current() {
      return get().current;
    },
    set current(value) {
      set((prev) => {
        if (prev.current === value) return prev;
        return { ...prev, current: value };
      });
    },
    toString() {
      return this.current.toString();
    },
    valueOf() {
      return this.current;
    }
  };
  return ref;
}
function h(tag, props, ...children) {
  if (tag === Fragment || Array.isArray(tag)) {
    const fragment = document.createDocumentFragment();
    const items = tag === Fragment ? (props == null ? void 0 : props.children) || children : tag;
    if (Array.isArray(items)) {
      const append = document.createTextNode.bind(document);
      items.forEach((child) => {
        fragment.appendChild(
          child instanceof Node ? child : child != null ? append(String(child)) : null
        );
      });
    }
    return fragment;
  }
  if (!tag) return null;
  const element = typeof tag === "function" ? tag(props) : document.createElement(tag);
  if (typeof tag === "string" && element && props) {
    diffProps({}, props, element);
  }
  if (children.length) {
    const fragment = document.createDocumentFragment();
    const appendChild = (child) => {
      if (child == null) return;
      if (typeof child === "function") {
        const textNode = document.createTextNode("");
        Effect(() => textNode.textContent = child());
        fragment.appendChild(textNode);
      } else if (child instanceof Node) {
        fragment.appendChild(child);
      } else if (Array.isArray(child)) {
        child.flat().forEach(appendChild);
      } else {
        fragment.appendChild(document.createTextNode(String(child)));
      }
    };
    children.forEach(appendChild);
    element.appendChild(fragment);
  }
  return element;
}
var Component = (Component2, props) => {
  if (typeof Component2 !== "function") {
    throw new Error("Invalid Component: must be a function");
  }
  return Component2(props);
};
var Fragment = (props) => props.children;
window.Fragment = Fragment;
var Olova = {
  render(component, container) {
    const newElement = typeof component === "function" ? component() : component;
    if (container.firstChild) {
      diffChildren([container.firstChild], [newElement], container);
    } else {
      container.appendChild(newElement);
    }
    return newElement;
  },
  mount(component, container) {
    return this.render(component, container);
  },
  unmount(container) {
    container.innerHTML = "";
  },
  Fragment
};
var contextRegistry = /* @__PURE__ */ new Map();
function Context(defaultValue) {
  const id = Symbol("context");
  contextRegistry.set(id, defaultValue);
  return {
    Provider({ value, children }) {
      const oldValue = contextRegistry.get(id);
      contextRegistry.set(id, value);
      const result = children;
      contextRegistry.set(id, oldValue);
      return result;
    },
    use() {
      const value = contextRegistry.get(id);
      if (value === void 0 && defaultValue === void 0) {
        throw new Error("Context used outside of Provider");
      }
      return value ?? defaultValue;
    }
  };
}
function Callback(fn, deps) {
  const [get, set] = State(() => ({
    fn,
    deps,
    memoized: (...args) => fn(...args)
  }));
  Effect(() => {
    const current = get();
    if (!deps) return;
    if (!current.deps || deps.length !== current.deps.length || deps.some((dep, i) => dep !== current.deps[i])) {
      set({
        fn,
        deps,
        memoized: (...args) => fn(...args)
      });
    }
  });
  return () => get().memoized;
}
var olova_default = Olova;
export {
  Callback,
  Component,
  Context,
  Effect,
  Fragment,
  Memo,
  Ref,
  State,
  olova_default as default,
  h
};
//# sourceMappingURL=olova.js.map
