let currentObserver = null;

// Diffing utilities
function diffProps(oldProps = {}, newProps = {}, element) {
  // Handle className to class conversion
  if (newProps.className !== undefined) {
    newProps.class = newProps.className;
    delete newProps.className;
  }
  if (oldProps.className !== undefined) {
    oldProps.class = oldProps.className;
    delete oldProps.className;
  }

  // Remove old props
  for (const [key, value] of Object.entries(oldProps)) {
    if (!(key in newProps)) {
      if (key.startsWith("on")) {
        element.removeEventListener(key.slice(2).toLowerCase(), value);
      } else if (key === "style") {
        element.style.cssText = "";
      } else {
        element.removeAttribute(key);
      }
    }
  }

  // Set new props
  for (const [key, value] of Object.entries(newProps)) {
    if (value == null) continue;
    if (oldProps[key] === value) continue;

    if (key.startsWith("on")) {
      const eventName = key.slice(2).toLowerCase();
      if (oldProps[key]) {
        element.removeEventListener(eventName, oldProps[key]);
      }
      element.addEventListener(eventName, value);
    } else if (key === "ref") {
      if (value && typeof value === "object" && "current" in value) {
        value.current = element;
      } else if (typeof value === "function") {
        value(element);
      }
    } else if (key === "style") {
      const style = element.style;
      if (typeof value === "object") {
        Object.assign(style, value);
      } else {
        style.cssText = value;
      }
    } else {
      element.setAttribute(key, value);
    }
  }
}

function diffChildren(oldChildren, newChildren, parent) {
  const oldChildrenArray = Array.isArray(oldChildren)
    ? oldChildren.flat()
    : [oldChildren];
  const newChildrenArray = Array.isArray(newChildren)
    ? newChildren.flat()
    : [newChildren];

  const maxLength = Math.max(oldChildrenArray.length, newChildrenArray.length);

  for (let i = 0; i < maxLength; i++) {
    const oldChild = oldChildrenArray[i];
    const newChild = newChildrenArray[i];

    // Remove extra old nodes
    if (oldChild && !newChild) {
      if (oldChild instanceof Node) {
        parent.removeChild(oldChild);
      }
      continue;
    }

    // Add new nodes
    if (!oldChild && newChild) {
      const node =
        newChild instanceof Node
          ? newChild
          : document.createTextNode(String(newChild));
      parent.appendChild(node);
      continue;
    }

    // Update existing nodes
    if (oldChild instanceof Node && newChild instanceof Node) {
      if (
        oldChild.nodeType !== newChild.nodeType ||
        oldChild.nodeName !== newChild.nodeName
      ) {
        parent.replaceChild(newChild, oldChild);
      } else {
        diffProps(oldChild.attributes, newChild.attributes, oldChild);
        diffChildren(
          Array.from(oldChild.childNodes),
          Array.from(newChild.childNodes),
          oldChild
        );
      }
    } else if (oldChild !== newChild) {
      // Text node updates
      const node = parent.childNodes[i];
      if (node) {
        node.textContent = String(newChild);
      }
    }
  }
}

class Signal {
  constructor(value) {
    this._value = value;
    this.observers = new Map();
  }

  get value() {
    if (currentObserver) {
      if (!this.observers.has("_root")) {
        this.observers.set("_root", new Set());
      }
      this.observers.get("_root").add(currentObserver);
    }
    return this._value;
  }

  set value(newValue) {
    if (this._value === newValue) return;
    const oldValue = this._value;
    this._value = newValue;

    if (this.observers.has("_root")) {
      for (const observer of this.observers.get("_root")) {
        observer();
      }
    }

    if (typeof oldValue === "object" && typeof newValue === "object") {
      const allProps = new Set([
        ...Object.keys(oldValue),
        ...Object.keys(newValue),
      ]);

      for (const prop of allProps) {
        if (oldValue[prop] !== newValue[prop] && this.observers.has(prop)) {
          for (const observer of this.observers.get(prop)) {
            observer();
          }
        }
      }
    }
  }

  observe(property, observer) {
    if (!this.observers.has(property)) {
      this.observers.set(property, new Set());
    }
    this.observers.get(property).add(observer);
  }

  unobserve(property, observer) {
    if (this.observers.has(property)) {
      this.observers.get(property).delete(observer);
    }
  }
}

function State(initialValue) {
  const sig = new Signal(initialValue);
  const getter = () => sig.value;
  getter.toString = () => sig.value;

  getter.observe = (prop, fn) => sig.observe(prop, fn);
  getter.unobserve = (prop, fn) => sig.unobserve(prop, fn);

  return [
    getter,
    (newValue) => {
      sig.value =
        typeof newValue === "function" ? newValue(sig.value) : newValue;
    },
  ];
}

function Effect(fn) {
  const execute = () => {
    currentObserver = execute;
    fn();
    currentObserver = null;
  };
  execute();
}

function Memo(fn) {
  const [get, set] = State(fn());
  Effect(() => set(fn()));
  return get;
}

function Ref(initialValue) {
  const [get, set] = State({
    current: initialValue,
    toString() {
      return this.current;
    },
    valueOf() {
      return this.current;
    },
  });

  const ref = {
    get current() {
      return get().current;
    },
    set current(value) {
      set((prev) => {
        if (prev.current === value) return prev;
        return { ...prev, current: value };
      });
    },
    toString() {
      return this.current.toString();
    },
    valueOf() {
      return this.current;
    },
  };

  return ref;
}

function h(tag, props, ...children) {
  if (tag === Fragment || Array.isArray(tag)) {
    const fragment = document.createDocumentFragment();
    const items = tag === Fragment ? props?.children || children : tag;

    if (Array.isArray(items)) {
      const append = document.createTextNode.bind(document);
      items.forEach((child) => {
        fragment.appendChild(
          child instanceof Node
            ? child
            : child != null
            ? append(String(child))
            : null
        );
      });
    }
    return fragment;
  }

  if (!tag) return null;

  const element =
    typeof tag === "function" ? tag(props) : document.createElement(tag);

  if (typeof tag === "string" && element && props) {
    diffProps({}, props, element);
  }

  if (children.length) {
    const fragment = document.createDocumentFragment();
    const appendChild = (child) => {
      if (child == null) return;

      if (typeof child === "function") {
        const textNode = document.createTextNode("");
        Effect(() => (textNode.textContent = child()));
        fragment.appendChild(textNode);
      } else if (child instanceof Node) {
        fragment.appendChild(child);
      } else if (Array.isArray(child)) {
        child.flat().forEach(appendChild);
      } else {
        fragment.appendChild(document.createTextNode(String(child)));
      }
    };

    children.forEach(appendChild);
    element.appendChild(fragment);
  }

  return element;
}

const Component = (Component, props) => {
  if (typeof Component !== "function") {
    throw new Error("Invalid Component: must be a function");
  }
  return Component(props);
};

const Fragment = (props) => props.children;

window.Fragment = Fragment;

const Olova = {
  render(component, container) {
    const newElement =
      typeof component === "function" ? component() : component;

    if (container.firstChild) {
      diffChildren([container.firstChild], [newElement], container);
    } else {
      container.appendChild(newElement);
    }

    return newElement;
  },

  mount(component, container) {
    return this.render(component, container);
  },

  unmount(container) {
    container.innerHTML = "";
  },

  Fragment,
};

const contextRegistry = new Map();

function Context(defaultValue) {
  const id = Symbol("context");
  contextRegistry.set(id, defaultValue);

  return {
    Provider({ value, children }) {
      const oldValue = contextRegistry.get(id);
      contextRegistry.set(id, value);
      const result = children;
      contextRegistry.set(id, oldValue);
      return result;
    },

    use() {
      const value = contextRegistry.get(id);
      if (value === undefined && defaultValue === undefined) {
        throw new Error("Context used outside of Provider");
      }
      return value ?? defaultValue;
    },
  };
}

function Callback(fn, deps) {
  const [get, set] = State(() => ({
    fn,
    deps,
    memoized: (...args) => fn(...args),
  }));

  Effect(() => {
    const current = get();
    if (!deps) return;

    if (
      !current.deps ||
      deps.length !== current.deps.length ||
      deps.some((dep, i) => dep !== current.deps[i])
    ) {
      set({
        fn,
        deps,
        memoized: (...args) => fn(...args),
      });
    }
  });

  return () => get().memoized;
}

export { State, Effect, Memo, Ref, Context, Callback, Component, h, Fragment };

export default Olova;
